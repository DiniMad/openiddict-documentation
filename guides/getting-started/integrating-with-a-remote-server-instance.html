<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Integrating with a remote server instance </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Integrating with a remote server instance ">
    <meta name="generator" content="docfx 2.56.7.0">
    
    <link rel="shortcut icon" href="../../images/favicon.ico">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/night-owl.min.css">
    <link rel="stylesheet" href="../../styles/colors.css">
    <link rel="stylesheet" href="../../styles/discord.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>

  <body>
        <div class="top-navbar">

            <a href="javascript:void(0);" class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="24" height="24" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>

            
            <a class="brand" href="../../index.html">
              <img src="../../images/logo.png" alt="OpenIddict" class="logomark">
              <span class="brand-title">OpenIddict</span>
            </a>
        </div>

        <div class="body-content">

            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">

                <div class="sidebar">
                    
                    
                    
                    
                    <div>
                      
                      <a class="brand" href="../../index.html">
                        <img src="../../images/logo.png" alt="OpenIddict" class="logomark">
                        <span class="brand-title">OpenIddict</span>
                      </a>
                      <div id="navbar">
                    
                      </div>
                    
                    </div>


                    <div class="sidebar-item-separator"></div>

                        
                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>

                </div>

                <div class="footer">
                  
                  <span>Generated by <strong>DocFX</strong></span>
                </div>
            </nav>

            <main class="main-panel">

                <div role="main" class="hide-when-search">

                        
                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                    <article class="content wrap" id="_content" data-uid="">
<h1 id="integrating-with-a-remote-server-instance">Integrating with a remote server instance</h1>

<p>The OpenIddict client is a universal OAuth 2.0/OpenID Connect .NET client that can be used in both web applications
(ASP.NET 4.6.1+ or ASP.NET Core 2.1+ required) or desktop applications (.NET 4.6.1+ or .NET 6.0+ required).</p>
<p>Most of the settings apply to both web and desktop applications but interactive flows like the
code or implicit flows require a specific integration depending on the type of application:</p>
<h2 id="implement-a-non-interactive-oauth-20-client-in-any-net-application">Implement a non-interactive OAuth 2.0 client in any .NET application:</h2>
<p>Non-interactive flows like the resource owner password credentials (ROPC) or client credentials are implemented the same way
in web and desktop applications. If you want to use a non-interactive flow like the client credentials flow, you&#39;ll need to:</p>
<ul>
<li><p><strong>Have an existing project or create a new one</strong>: using the .NET generic host is recommended but not mandatory for non-interactive
flows. In any case, you&#39;ll need to use dependency injection (<code>Microsoft.Extensions.DependencyInjection</code> or another DI container).</p>
</li>
<li><p><strong>Update your <code>.csproj</code> file</strong> to reference the latest <code>OpenIddict</code> package:</p>
<pre><code class="lang-xml">&lt;PackageReference Include=&quot;OpenIddict&quot; Version=&quot;5.4.0&quot; /&gt;
</code></pre></li>
<li><p><strong>Configure the OpenIddict client services</strong> in <code>Program.cs</code> (or <code>Startup.cs</code> if you use the regular ASP.NET Core web host):</p>
<pre><code class="lang-csharp">services.AddOpenIddict()

    // Register the OpenIddict client components.
    .AddClient(options =&gt;
    {
        // Allow grant_type=client_credentials to be negotiated.
        options.AllowClientCredentialsFlow();

        // Disable token storage, which is not necessary for non-interactive flows like
        // grant_type=password, grant_type=client_credentials or grant_type=refresh_token.
        options.DisableTokenStorage();

        // Register the System.Net.Http integration.
        options.UseSystemNetHttp();

        // Add a client registration with the client identifier and secrets issued by the server.
        options.AddRegistration(new OpenIddictClientRegistration
        {
            Issuer = new Uri(&quot;https://localhost:44385/&quot;, UriKind.Absolute),

            ClientId = &quot;service-worker&quot;,
            ClientSecret = &quot;388D45FA-B36B-4988-BA59-B187D329C207&quot;
        });
    });
</code></pre></li>
<li><p><strong>Use <code>OpenIddictClientService</code> to retrieve an access token from the remote server:</strong></p>
<pre><code class="lang-csharp">var service = provider.GetRequiredService&lt;OpenIddictClientService&gt;();

var result = await service.AuthenticateWithClientCredentialsAsync(new());
var token = result.AccessToken;
</code></pre></li>
</ul>
<h2 id="implement-an-interactive-oauth-20openid-connect-client-in-an-aspnet-core-application">Implement an interactive OAuth 2.0/OpenID Connect client in an ASP.NET Core application:</h2>
<p><strong>To implement an interactive OAuth 2.0/OpenID Connect client in an ASP.NET Core application, the simplest option is to clone
one of the official samples</strong> from the <a href="https://github.com/openiddict/openiddict-samples">openiddict-samples repository</a>.</p>
<p>If you don&#39;t want to start from one of the recommended samples, you&#39;ll need to:</p>
<ul>
<li><p><strong>Have an existing project or create a new one</strong>: when creating a new project using Visual Studio&#39;s default ASP.NET Core template,
using <strong>individual user accounts authentication</strong> is strongly recommended as it automatically includes a default ASP.NET Core Identity UI
based on Razor Pages, that automatically handles the user creation process or external login integration in a transparent way.</p>
</li>
<li><p><strong>Update your <code>.csproj</code> file</strong> to reference the latest <code>OpenIddict.AspNetCore</code> and <code>OpenIddict.EntityFrameworkCore</code> packages:</p>
<pre><code class="lang-xml">&lt;PackageReference Include=&quot;OpenIddict.AspNetCore&quot; Version=&quot;5.4.0&quot; /&gt;
&lt;PackageReference Include=&quot;OpenIddict.EntityFrameworkCore&quot; Version=&quot;5.4.0&quot; /&gt;
</code></pre></li>
<li><p><strong>Configure the OpenIddict core services</strong> in <code>Program.cs</code> (or <code>Startup.cs</code>, depending on whether you&#39;re using the minimal host or the regular host):</p>
<div class="IMPORTANT"><h5>Important</h5><p>Configuring a database is required because the OpenIddict client is stateful by default: it uses the <code>IOpenIddictTokenStore&lt;T&gt;</code>
service to store the payload of the state tokens it creates – to protect the callback stage from CSRF/session fixation attacks –
and enable automatic state token redeeming (unlike the ASP.NET Core OAuth 2.0 or OpenID Connect handlers, the OpenIddict client
prevents state tokens from being used multiple times to mitigate authorization response/state token replay attacks).</p>
</div>
<pre><code class="lang-csharp">services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
{
    // Configure Entity Framework Core to use Microsoft SQL Server.
    options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;));

    // Register the entity sets needed by OpenIddict.
    // Note: use the generic overload if you need to replace the default OpenIddict entities.
    options.UseOpenIddict();
});
</code></pre><pre><code class="lang-csharp">services.AddOpenIddict()

    // Register the OpenIddict core components.
    .AddCore(options =&gt;
    {
        // Configure OpenIddict to use the Entity Framework Core stores and models.
        // Note: call ReplaceDefaultEntities() to replace the default entities.
        options.UseEntityFrameworkCore()
               .UseDbContext&lt;ApplicationDbContext&gt;();
    });
</code></pre></li>
<li><p><strong>Configure the OpenIddict client services</strong>. Here&#39;s an example enabling code flow support and adding the GitHub integration:</p>
<pre><code class="lang-csharp">services.AddOpenIddict()

    // Register the OpenIddict client components.
    .AddClient(options =&gt;
    {
        // Note: this sample only uses the authorization code flow,
        // but you can enable the other flows if necessary.
        options.AllowAuthorizationCodeFlow();

        // Register the signing and encryption credentials used to protect
        // sensitive data like the state tokens produced by OpenIddict.
        options.AddDevelopmentEncryptionCertificate()
               .AddDevelopmentSigningCertificate();

        // Register the ASP.NET Core host and configure the ASP.NET Core-specific options.
        options.UseAspNetCore()
               .EnableRedirectionEndpointPassthrough();

        // Register the System.Net.Http integration.
        options.UseSystemNetHttp();

        // Register the Web providers integrations.
        //
        // Note: to mitigate mix-up attacks, it&#39;s recommended to use a unique redirection endpoint
        // URI per provider, unless all the registered providers support returning a special &quot;iss&quot;
        // parameter containing their URL as part of authorization responses. For more information,
        // see https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#section-4.4.
        options.UseWebProviders()
               .AddGitHub(options =&gt;
               {
                   options.SetClientId(&quot;c4ade52327b01ddacff3&quot;)
                          .SetClientSecret(&quot;da6bed851b75e317bf6b2cb67013679d9467c122&quot;)
                          .SetRedirectUri(&quot;callback/login/github&quot;);
               });
    });
</code></pre></li>
<li><p><strong>Make sure the ASP.NET Core authentication middleware is correctly registered at the right place</strong>:</p>
<pre><code class="lang-csharp">app.UseDeveloperExceptionPage();

app.UseRouting();
app.UseCors();

app.UseAuthentication();
app.UseAuthorization();

app.UseEndpoints(options =&gt;
{
    options.MapControllers();
    options.MapDefaultControllerRoute();
});
</code></pre></li>
<li><p><strong>Add an authentication controller responsible for handling the OAuth 2.0/OpenID Connect callbacks:</strong></p>
<pre><code class="lang-csharp">[HttpGet(&quot;~/callback/login/{provider}&quot;), HttpPost(&quot;~/callback/login/{provider}&quot;), IgnoreAntiforgeryToken]
public async Task&lt;ActionResult&gt; LogInCallback()
{
    // Retrieve the authorization data validated by OpenIddict as part of the callback handling.
    var result = await HttpContext.AuthenticateAsync(OpenIddictClientAspNetCoreDefaults.AuthenticationScheme);

    // Important: if the remote server doesn&#39;t support OpenID Connect and doesn&#39;t expose a userinfo endpoint,
    // result.Principal.Identity will represent an unauthenticated identity and won&#39;t contain any user claim.
    //
    // Such identities cannot be used as-is to build an authentication cookie in ASP.NET Core (as the
    // antiforgery stack requires at least a name claim to bind CSRF cookies to the user&#39;s identity) but
    // the access/refresh tokens can be retrieved using result.Properties.GetTokens() to make API calls.
    if (result.Principal is not ClaimsPrincipal { Identity.IsAuthenticated: true })
    {
        throw new InvalidOperationException(&quot;The external authorization data cannot be used for authentication.&quot;);
    }

    // Build an identity based on the external claims and that will be used to create the authentication cookie.
    var identity = new ClaimsIdentity(authenticationType: &quot;ExternalLogin&quot;);

    // By default, OpenIddict will automatically try to map the email/name and name identifier claims from
    // their standard OpenID Connect or provider-specific equivalent, if available. If needed, additional
    // claims can be resolved from the external identity and copied to the final authentication cookie.
    identity.SetClaim(ClaimTypes.Email, result.Principal.GetClaim(ClaimTypes.Email))
            .SetClaim(ClaimTypes.Name, result.Principal.GetClaim(ClaimTypes.Name))
            .SetClaim(ClaimTypes.NameIdentifier, result.Principal.GetClaim(ClaimTypes.NameIdentifier));

    // Preserve the registration identifier to be able to resolve it later.
    identity.SetClaim(Claims.Private.RegistrationId, result.Principal.GetClaim(Claims.Private.RegistrationId));

    // Build the authentication properties based on the properties that were added when the challenge was triggered.
    var properties = new AuthenticationProperties(result.Properties.Items)
    {
        RedirectUri = result.Properties.RedirectUri ?? &quot;/&quot;
    };

    // If needed, the tokens returned by the authorization server can be stored in the authentication cookie.
    //
    // To make cookies less heavy, tokens that are not used are filtered out before creating the cookie.
    properties.StoreTokens(result.Properties.GetTokens().Where(token =&gt; token.Name is
        // Preserve the access, identity and refresh tokens returned in the token response, if available.
        OpenIddictClientAspNetCoreConstants.Tokens.BackchannelAccessToken   or
        OpenIddictClientAspNetCoreConstants.Tokens.BackchannelIdentityToken or
        OpenIddictClientAspNetCoreConstants.Tokens.RefreshToken));

    // Ask the default sign-in handler to return a new cookie and redirect the
    // user agent to the return URL stored in the authentication properties.
    //
    // For scenarios where the default sign-in handler configured in the ASP.NET Core
    // authentication options shouldn&#39;t be used, a specific scheme can be specified here.
    return SignIn(new ClaimsPrincipal(identity), properties);
}
</code></pre></li>
<li><p>Once correctly configured, the GitHub provider should appear in the list of supported external providers:</p>
</li>
</ul>
<p><img src="integrating-with-a-remote-server-instance/identity-ui.png" alt="Identity UI showing GitHub as a supported external provider"></p>
<h2 id="implement-an-interactive-oauth-20openid-connect-client-in-a-desktop-application">Implement an interactive OAuth 2.0/OpenID Connect client in a desktop application:</h2>
<p><strong>To implement an interactive OAuth 2.0/OpenID Connect client in a desktop application, the simplest option is to clone
one of the official samples</strong> from the <a href="https://github.com/openiddict/openiddict-samples">openiddict-samples repository</a>.</p>
<p>For more information on how to use the <code>OpenIddict.Client.SystemIntegration</code> package on Linux and Windows, read
<a href="https://kevinchalet.com/2023/02/27/introducing-system-integration-support-for-the-openiddict-client/">Introducing system integration support for the OpenIddict client</a>.</p>
</article>
              
                </div>
            </main>
        </div>

        
<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<script type="text/javascript" src="../../styles/jquery.twbsPagination.js"></script>
<script type="text/javascript" src="../../styles/url.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script>
<script type="text/javascript" src="../../styles/docfx.js"></script>
<script type="text/javascript" src="../../styles/main.js"></script>

    </body>

</html>
